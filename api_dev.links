module JSFFI {
  alien javascript "/js/vid_calling.js" {
    playLocalVideo : (String) ~> ();
    setName : () ~> ();
    getLocalName : () ~> (String);
    toString : (String) ~> (String);
    getID: () ~> (String);
    setID: () ~> ();

    createOffer: (String) ~> ();
    createAnswer: (String, String) ~> ();
    createAccept: (String, String) ~> ();
    checkAsyncDone: (String) ~> (String);

    checkForIceCandidates: (String) ~> (String);
    newRemoteCandidate: (String, String) ~> ();
  }
}

fun displayLocalVid() {
  var vidXML = <video id = "local_vid" autoplay = "true" style="object-fit:cover; width:320px; height:240px"></video>;
  appendChildren(vidXML, getNodeById("vids"));

  JSFFI.playLocalVideo("local_vid")
}

fun getSelfInfo() {
  var name = JSFFI.getLocalName();
  var id = JSFFI.getID();

  (clientName = name, clientID = id)
}

##WebRTC Functions

fun waitForAsync(foreignID){

  var response = JSFFI.checkAsyncDone(foreignID);

  if (response <> "wait") {
    response
    }
    else {
      waitForAsync(foreignID)
    }
}


fun checkCandidates(serverPid, foreignID) {
  var candidate = JSFFI.checkForIceCandidates(foreignID);

  if (candidate <> "None") {

    var localID = JSFFI.getID();

    serverPid ! Broadcast(VidMessage(senderID = localID, destID = foreignID, msgType = "ice", data = candidate));

    checkCandidates(serverPid, foreignID)
  }
  else {
    checkCandidates(serverPid, foreignID)
  }
}

### CLIENT

##Message Types:
##VidMessage(senderID = id, destID = id, msgType = type, data = data)

fun handleVidMessage(serverPid, msg) {

  var localID = JSFFI.getID();

  var destID = JSFFI.toString(msg.destID);

  var foreignID = JSFFI.toString(msg.senderID);

  var type = JSFFI.toString(msg.msgType);

  print("I am " ^^ localID ^^ " this is for " ^^ destID ^^ " from " ^^ foreignID);

  if(localID <> destID) {
    print("I don't think this is for me")
  }
  else {

    print("I think this is for me");

    switch(type) {
      case "initial" ->
        print("This is an initial VidMessage");
        JSFFI.createOffer(foreignID);
        var offerStr = waitForAsync(foreignID);
        print(offerStr);
        serverPid ! Broadcast(VidMessage(senderID = localID, destID = foreignID, msgType = "offer", data = offerStr));

        var iceClient = spawnClient { checkCandidates(serverPid, foreignID) };

        print("I am " ^^ localID ^^ " sending an offer to " ^^ foreignID);
        ()

      case "offer" ->
        print("This is an offer VidMessage");

        var offerStr = JSFFI.toString(msg.data);
        JSFFI.createAnswer(foreignID,offerStr);

        var answerStr = waitForAsync(foreignID);

        serverPid ! Broadcast(VidMessage(senderID = localID, destID = foreignID, msgType = "accept", data = answerStr));

        var iceClient = spawnClient { checkCandidates(serverPid, foreignID) };

        print("I am " ^^ localID ^^ " sending an accept to " ^^ foreignID);
        ()

      case "accept" ->
        print("This is an accept VidMessage");
        var answerStr = JSFFI.toString(msg.data);
        JSFFI.createAccept(foreignID,answerStr);

        var _ = waitForAsync(foreignID);

        print("I am " ^^ localID ^^ " accepting an offer from " ^^ foreignID);
        ()

      case "ice" ->
        print("This is an ICE VidMessage");
        var candidate = JSFFI.toString(msg.data);
        JSFFI.newRemoteCandidate(foreignID,candidate);
        ()
    }
  }
}

fun addToRoom(clientID, clientName, roomNum){

  print(roomNum);

  if (roomNum == "0"){
    print("roomNum found to be 0");
    ()
  }
  else {
    #var xmlid = "NameOf" ^^ clientID;

    var nameXML = <div><body>{stringToXml(clientName)}</body></div>;
    appendChildren(nameXML, getNodeById(roomNum));

    ()
  }
}


##StateUpdate((clientInfo(clientID, clientName, room)[]))

fun handleStateUpdate(clientArr) {
#  switch (clientArr) {
#    case [] ->
#    print("out of clients");
#    ()
#    case c::clientArr ->
#      print("client in clientArr");
#
#      var id = JSFFI.toString(c.clientID);
#      var name = JSFFI.toString(c.clientName);
#      var roomNum = JSFFI.toString(c.room);
#      print(id ^^ name ^^ roomNum);
#
#      addToRoom(id, name, roomNum);
#      handleStateUpdate(clientArr)
#  }

  var _ = for (c <- clientArr) {
    print("client in clientArr");

    var id = JSFFI.toString(c.clientID);
    var name = JSFFI.toString(c.clientName);
    var roomNum = JSFFI.toString(c.room);
    print(id ^^ name ^^ roomNum);

    addToRoom(id, name, roomNum);
    []
  };
  ()
}

## Loop thread run on the client, listens for NewClient messages from the server
## and prints a message to the console whenever one is received
fun clientLoop(serverPid) {
    receive {
        case NewClient(msg) ->

            var localID = JSFFI.getID();

            print("New client registered " ^^ localID);

            var foreignID = JSFFI.toString(msg.clientID);


            if(localID <> foreignID) {
              serverPid ! Broadcast(VidMessage(senderID = localID, destID = foreignID, msgType = "initial", data = ""));
              print("New User!");
              print(localID ^^ "," ^^ foreignID);
              clientLoop(serverPid)
            }
            else {
              print("My own register");
              print(localID ^^ "," ^^ foreignID);
              clientLoop(serverPid)
            }


        case VidMessage(msg) ->
          print("VidMessage Received from " ^^ JSFFI.toString(msg.senderID));
          handleVidMessage(serverPid, msg);
          clientLoop(serverPid)

        case StateUpdate(msg) ->
          print("StateUpdate Received");
          handleStateUpdate(msg);
          clientLoop(serverPid)
    }

}

## Run on the client whenever the page has loaded.
## Registers itself with the server, then proceeds to loop, awaiting messages
## from the server
fun clientRegister(serverPid) {

    JSFFI.setName();
    JSFFI.setID();

    var name = JSFFI.getLocalName();
    var id = JSFFI.getID();
    displayLocalVid();

    var clientInfo = (clientID = id, clientName = name, room = "0");

    serverPid ! Register(self(), clientInfo);

    clientLoop(serverPid)
}

## Run on the server to generate a page for the client. Spawns a process on the
## client and generates the HTML.

fun mainPage(serverPid) {

  var clientPid = spawnClient { clientRegister(serverPid) };

  page
  <html>
    <body>
    <div id = "1">
      <form l:onsubmit="{serverPid ! ChangeRoom(JSFFI.getID(), "1")}">
        <button type="submit">Room 1</button>
      </form>
    </div>
     <div id = "2">
      <form l:onsubmit="{serverPid ! ChangeRoom(JSFFI.getID(), "2")}">
        <button type="submit">Room 2</button>
      </form>
    </div>
    <div id = "vids"></div>

    </body>
  </html>

}

### SERVER
## Sends a message to a list of clients
fun broadcast(clients, msg) server {
    switch (clients) {
        case [] -> ()
        case (c,_)::clients ->
            c ! msg;
            broadcast(clients, msg)
    }
}

# Loops, keeping track of the client PIDs
fun serverLoop(clients) server {
    receive {
        case Register(pid, clientInfo) ->
            var newClients = (pid, clientInfo) :: clients;
            # Broadcast a "New Client" message
            broadcast(newClients, NewClient(clientInfo));

            var infoToSend = for ((_ , clientInfo) <- newClients){
              [clientInfo]
            };

            broadcast(newClients, StateUpdate(infoToSend));

            serverLoop(newClients)

        #case Send(targetID, msg) ->

        #  var target = for (client <- clients) where (JSFFI.toString((client.2).clientID) == targetID) [client];

        #  broadcast(target, msg);
        #  serverLoop(clients)

        case Broadcast(msg) ->
          broadcast(clients, msg);
          serverLoop(clients)

        case ChangeRoom(userID, newRoom) ->
          var newClients = for ((pid , clientInfo) <- clients)
            if (JSFFI.toString(clientInfo.clientID) == userID)
              [(pid, (clientID = JSFFI.toString(clientInfo.clientID), clientName = JSFFI.toString(clientInfo.clientName), room = newRoom))]
            else
              [(pid, clientInfo)];

          var infoToSend = for ((_ , clientInfo) <- newClients) [clientInfo];

          broadcast(newClients, StateUpdate(infoToSend));

          serverLoop(newClients)

    }
}


# Main method, run once when the server is started
fun main() {
    # Spawns a process on the server which keeps track of all clients
    var serverPid = spawn { serverLoop([]) };
    # Registers the "mainPage" route
    addRoute("/", fun(_) { mainPage(serverPid) });
    addStaticRoute("/js", "js", [("js", "text/javascript")]);
    # Starts the server and distribution
    serveWebsockets();
    servePages()
}


main()

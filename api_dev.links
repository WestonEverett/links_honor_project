module JSFFI {
  alien javascript "/js/vid_calling.js" {
    playLocalVideo : (String) ~> ();
    setName : () ~> ();
    getLocalName : () ~> (String);
    toString : (String) ~> (String);
    getID: () ~> (String);
    setID: () ~> ();

    createOffer: () ~> (String);
    receiveOffer: (String) ~> (String);
  }
}

fun displayLocalVid() {
  var vidXML = <video id = "local_vid" autoplay = "true" style="object-fit:cover; width:320px; height:240px"></video>;
  appendChildren(vidXML, getNodeById("vids"));
  JSFFI.playLocalVideo("local_vid")
}

fun getSelfInfo() {
  var name = JSFFI.getLocalName();
  var id = JSFFI.getID();

  (clientName = name, clientID = id)
}

##WebRTC Functions

fun attemptCall(msg){

}


### CLIENT

##Message Types:
##VidMessage(senderID = id, destID = id, msgType = type, data = data)

fun handleVidMessage(serverPid, msg) {

  var localID = JSFFI.getID();

  var destID = JSFFI.toString(msg.destID);

  var foreignID = JSFFI.toString(msg.senderID);

  var type = JSFFI.toString(msg.msgType);

  print("I am " ^^ localID ^^ " this is for " ^^ destID ^^ " from " ^^ foreignID);

  if(localID <> destID) {
    print("I don't think this is for me")
  }
  else {

    print("I think this is for me");

    switch(type) {
      case "initial" ->
        print("This is an initial VidMessage");
        var offerStr = JSFFI.createOffer();
        print(offerStr);
        serverPid ! Broadcast(VidMessage(senderID = localID, destID = foreignID, msgType = "offer", data = offerStr));
        print("I am " ^^ localID ^^ " sending an offer to " ^^ foreignID);
        ()

      case "offer" ->
        print("This is an offer VidMessage");
        var offerStr = JSFFI.toString(msg.data);
        var acceptStr = JSFFI.receiveOffer(offerStr);
        serverPid ! Broadcast(VidMessage(senderID = localID, destID = foreignID, msgType = "accept", data = acceptStr));
        print("I am " ^^ localID ^^ " sending an accept to " ^^ foreignID);
        ()

      case "accept" ->
        print("accept VidMessage received");
        ()
    }
  }
}

## Loop thread run on the client, listens for NewClient messages from the server
## and prints a message to the console whenever one is received
fun clientLoop(serverPid) {
    receive {
        case NewClient(msg) ->

            var localID = JSFFI.getID();

            print("New client registered " ^^ localID);

            var foreignID = JSFFI.toString(msg.clientID);


            if(localID <> foreignID) {
              serverPid ! Broadcast(VidMessage(senderID = localID, destID = foreignID, msgType = "initial", data = ""));
              print("New User!");
              print(localID ^^ "," ^^ foreignID);
              clientLoop(serverPid)
            }
            else {
              print("My own register");
              print(localID ^^ "," ^^ foreignID);
              clientLoop(serverPid)
            }


        case VidMessage(msg) ->
          print("VidMessage Received from " ^^ JSFFI.toString(msg.senderID));
          handleVidMessage(serverPid, msg);
          clientLoop(serverPid)
    }

}

## Run on the client whenever the page has loaded.
## Registers itself with the server, then proceeds to loop, awaiting messages
## from the server
fun clientRegister(serverPid) {

    JSFFI.setName();
    JSFFI.setID();

    var name = JSFFI.getLocalName();
    var id = JSFFI.getID();
    displayLocalVid();

    var clientInfo = (clientID = id, clientName = name);

    serverPid ! Register(self(), clientInfo);

    clientLoop(serverPid)
}

## Run on the server to generate a page for the client. Spawns a process on the
## client and generates the HTML.

fun mainPage(serverPid) {

  var clientPid = spawnClient { clientRegister(serverPid) };

  page
  <html>
    <body>
    <div id = "vids"></div>
    <div id = "users"></div>
    </body>
  </html>

}

### SERVER
## Sends a message to a list of clients
fun broadcast(clients, msg) server {
    switch (clients) {
        case [] -> ()
        case (c,_)::clients ->
            c ! msg;
            broadcast(clients, msg)
    }
}

# Loops, keeping track of the client PIDs
fun serverLoop(clients) server {
    receive {
        case Register(pid, clientInfo) ->
            var newClients = (pid, clientInfo) :: clients;
            # Broadcast a "New Client" message
            broadcast(newClients, NewClient(clientInfo));
            serverLoop(newClients)

        case Send(targets, msg) ->
          broadcast(targets, msg);
          serverLoop(clients)

        case Broadcast(msg) ->
          broadcast(clients, msg);
          serverLoop(clients)

    }
}


# Main method, run once when the server is started
fun main() {
    # Spawns a process on the server which keeps track of all clients
    var serverPid = spawn { serverLoop([]) };
    # Registers the "mainPage" route
    addRoute("/", fun(_) { mainPage(serverPid) });
    addStaticRoute("/js", "js", [("js", "text/javascript")]);
    # Starts the server and distribution
    serveWebsockets();
    servePages()
}


main()

module JSFFI {
  alien javascript "/js/vid_calling.js" {
    playLocalVideo : (String) ~> ();
    setName : () ~> ();
    getLocalName : () ~> (String);
    toString : (String) ~> (String);
    getID: () ~> (String);
    setID: () ~> ();
  }
}

fun displayLocalVid() {
  var vidXML = <video id = "local_vid" autoplay = "true" style="object-fit:cover; width:320px; height:240px"></video>;
  appendChildren(vidXML, getNodeById("vids"));
  JSFFI.playLocalVideo("local_vid")
}

fun getSelfInfo() {
  var name = JSFFI.getLocalName();
  var id = JSFFI.getID();

  (clientName = name, clientID = id)
}

##WebRTC Functions

fun attemptCall(msg){

}


### CLIENT

##Message Types:
##VidMessage(senderInfo = (clientName=name, clientID=id), msgType = type)

fun handleVidMessage(msg) {
  var localInfo = getSelfInfo();
  var foreignInfo = msg.senderInfo;
  var type = JSFFI.toString(msg.msgType);

  switch(type) {
    case "initial" ->
    print("something");
    
    ()

    case "offer" ->
    print("something");
    ()

    case "accept" ->
    print("something");
    ()
  };

  ()
}

## Loop thread run on the client, listens for NewClient messages from the server
## and prints a message to the console whenever one is received
fun clientLoop(serverPid) {
    receive {
        case NewClient(msg) ->
            print("New client registered.");
            clientLoop(serverPid)

        case VidMessage(msg) ->
          print("VidMessage Received");
          handleVidMessage(msg);
          clientLoop(serverPid)
    }

}

## Run on the client whenever the page has loaded.
## Registers itself with the server, then proceeds to loop, awaiting messages
## from the server
fun clientRegister(serverPid) {

    JSFFI.setName();
    JSFFI.setID();


    displayLocalVid();

    var clientInfo = getSelfInfo();

    serverPid ! Register(self(), clientInfo);

    clientLoop(serverPid)
}

## Run on the server to generate a page for the client. Spawns a process on the
## client and generates the HTML.

fun mainPage(serverPid) {

  var clientPid = spawnClient { clientRegister(serverPid) };

  page
  <html>
    <body>
    <div id = "vids"></div>
    <div id = "users"></div>
    </body>
  </html>

}

### SERVER
## Sends a message to a list of clients
fun broadcast(clients, msg) server {
    switch (clients) {
        case [] -> ()
        case (c,_)::clients ->
            c ! msg;
            broadcast(clients, msg)
    }
}

# Loops, keeping track of the client PIDs
fun serverLoop(clients) server {
    receive {
        case Register(pid, clientInfo) ->
            var newClients = (pid, clientInfo) :: clients;
            # Broadcast a "New Client" message
            broadcast(newClients, NewClient(clientInfo));
            serverLoop(newClients)

        case Send(targets, msg) ->
          broadcast(targets, msg);
          serverLoop(clients)

        case Broadcast(msg) ->
          broadcast(clients, msg);
          serverLoop(clients)

    }
}


# Main method, run once when the server is started
fun main() {
    # Spawns a process on the server which keeps track of all clients
    var serverPid = spawn { serverLoop([]) };
    # Registers the "mainPage" route
    addRoute("/", fun(_) { mainPage(serverPid) });
    addStaticRoute("/js", "js", [("js", "text/javascript")]);
    # Starts the server and distribution
    serveWebsockets();
    servePages()
}


main()

module JSFFI {
  alien javascript "/js/vid_calling.js" {
    playLocalVideo : (String) ~> ();
    setName : () ~> ();
    askForYesNo : (String) ~> (String); #Possible bug, JSFFI issue returning Bool (doesn't recognize)
    getLocalName : () ~> (String);
    toString : (String) ~> (String);
    getID: () ~> (String);
    setID: () ~> ();

    createOffer: (String) ~> ();
    createAnswer: (String, String) ~> ();
    createAccept: (String, String) ~> ();
    checkAsyncDone: (String) ~> (String);
    hangup: (String) ~> ();
    hangupAll: () ~> ();
    togMute: (String) ~> ();

    checkForIceCandidates: (String) ~> (String);
    newRemoteCandidate: (String, String) ~> ();
  }
}

fun displayLocalVid() {
  var vidXML = <video id = "local_vid" autoplay = "true" style="object-fit:cover; width:320px; height:240px"></video>;
  appendChildren(vidXML, getNodeById("vids"));

  JSFFI.playLocalVideo("local_vid")
}

fun getSelfInfo() {
  var name = JSFFI.getLocalName();
  var id = JSFFI.getID();

  (clientName = name, clientID = id)
}

##WebRTC Functions

fun waitForAsync(foreignID){

  var response = JSFFI.checkAsyncDone(foreignID);

  if (response <> "wait") {
    response
    }
    else {
      waitForAsync(foreignID)
    }
}


fun checkCandidates(serverPid, foreignID) {
  var candidate = JSFFI.checkForIceCandidates(foreignID);

  if (candidate <> "None") {

    var localID = JSFFI.getID();

    serverPid ! Send(foreignID, VidMessage(senderID = localID, destID = foreignID, msgType = "ice", data = candidate));

    checkCandidates(serverPid, foreignID)
  }
  else {
    checkCandidates(serverPid, foreignID)
  }
}

### CLIENT

##Message Types:
##VidMessage(senderID = id, destID = id, msgType = type, data = data)

fun handleVidMessage(serverPid, msg) {

  var localID = JSFFI.getID();

  var destID = JSFFI.toString(msg.destID);

  var foreignID = JSFFI.toString(msg.senderID);

  var type = JSFFI.toString(msg.msgType);

  #print("I am " ^^ localID ^^ " this is for " ^^ destID ^^ " from " ^^ foreignID);

  if(localID <> destID) {
    print("I don't think this is for me")
  }
  else {

    #print("I think this is for me");

    switch(type) {
      case "initial" ->
        #print("This is an initial VidMessage");
        JSFFI.createOffer(foreignID);
        var offerStr = waitForAsync(foreignID);
        #print(offerStr);
        serverPid ! Send(foreignID, VidMessage(senderID = localID, destID = foreignID, msgType = "offer", data = offerStr));

        var iceClient = spawnClient { checkCandidates(serverPid, foreignID) };

        #print("I am " ^^ localID ^^ " sending an offer to " ^^ foreignID);
        ()

      case "offer" ->
        #print("This is an offer VidMessage");

        var offerStr = JSFFI.toString(msg.data);
        JSFFI.createAnswer(foreignID,offerStr);

        var answerStr = waitForAsync(foreignID);

        serverPid ! Send(foreignID, VidMessage(senderID = localID, destID = foreignID, msgType = "accept", data = answerStr));

        var iceClient = spawnClient { checkCandidates(serverPid, foreignID) };

        #print("I am " ^^ localID ^^ " sending an accept to " ^^ foreignID);
        ()

      case "accept" ->
        #print("This is an accept VidMessage");
        var answerStr = JSFFI.toString(msg.data);
        JSFFI.createAccept(foreignID,answerStr);

        var _ = waitForAsync(foreignID);

        #print("I am " ^^ localID ^^ " accepting an offer from " ^^ foreignID);
        ()

      case "ice" ->
        #print("This is an ICE VidMessage");
        var candidate = JSFFI.toString(msg.data);
        JSFFI.newRemoteCandidate(foreignID,candidate);
        ()
    }
  }
}

##changedInfo = clientInfo record
fun moveToRoom(changedInfo){

  var clientID = changedInfo.clientID;
  var clientName = changedInfo.clientName;
  var roomNum = changedInfo.room;

  print("placing " ^^ clientName ^^ " with id " ^^ clientID ^^ " in room " ^^ roomNum);
  var divID = "DivOf" ^^ clientID;
  var checkID = "CheckOf" ^^ clientID;

  var node = getNodeById(divID);

  var clientPid = self();

  if(not(isNull(node))){
    var tempXML = <div id="tempNodeID"></div>;
    appendChildren(tempXML, getNodeById(roomNum));

    var tempNode = getNodeById("tempNodeID");

    swapNodes(node, tempNode);

    removeNode(tempNode)
  } else {
    var nameXML =
      <div id = "{divID}">
        <input type="checkbox" id="{checkID}" name="{checkID}" value="{clientID}"></input>
        <label for="{checkID}">{stringToXml(clientName)}</label>
          <button type="submit" l:onclick="{clientPid ! ToggleMute(clientID)}">Mute</button>
      </div>;

    appendChildren(nameXML, getNodeById(roomNum))
  };


  ()
}


##StateUpdate((clientInfo(clientID, clientName, room)))

fun handleStateUpdate(serverPid, oldOthersInfo, myInfo, changedInfo) {

  var newOthersInfo = for (c <- oldOthersInfo) {
    if (c.clientID == changedInfo.clientID) {

      if(and([c.room == myInfo.room, myInfo.room <> "0"])){
        JSFFI.hangup(c.clientID);
        print("Hanging up with " ^^ c.clientID)
      }
      else {
      ()
      };

      if(and([changedInfo.room == myInfo.room, myInfo.room <> "0"])) {
        serverPid ! Send(changedInfo.clientID, VidMessage(senderID = myInfo.clientID, destID = changedInfo.clientID, msgType = "initial", data = ""));
        print("Sending Init VidMessage to " ^^ changedInfo.clientID)
      } else {};

      moveToRoom(changedInfo);

      [changedInfo]
    }
    else {
      [c]
    }
  };
  newOthersInfo
}

##InitialState([clientInfo(clientID, clientName, room)])
fun handleInitialState(clientArr) {

  var _ = for (c <- clientArr) {
    moveToRoom(c);
    []
  };
  ()
}

fun getAllCheckedIDs(){

  var roomTopNode = getNodeById("rooms");

  var allRoomNodes = domGetChildrenFromRef(roomTopNode);

  var allNodes = for(roomTopNode <- allRoomNodes) domGetChildrenFromRef(roomTopNode);

  for (cNode <- allNodes) {
    var tagName = domGetTagNameFromRef(cNode);

    if(domGetTagNameFromRef(cNode) == "DIV") {
      var inputBox = nextSibling(firstChild(cNode));

      if(domGetPropertyFromRef(inputBox, "checked") == "true"){
        [domGetAttributeFromRef(inputBox, "value")]
      } else {
        []
      }
    } else {
      []
    }
  }
}

fun changeToRoom(myInfo, toRoom, serverPid) {
  if(myInfo.room <> toRoom) {
    JSFFI.hangupAll();

    serverPid ! ChangeRoom(JSFFI.getID(), toRoom);
    var myNewInfo = (clientID = myInfo.clientID, clientName = myInfo.clientName, room = toRoom);
    moveToRoom(myNewInfo);

    myNewInfo
    } else {myInfo}
}

fun handleMigrate(serverPid, myInfo, event) {

  var curNode = getTarget(event);
  var curDiv = parentNode(curNode);
  var toRoom = domGetAttributeFromRef(curDiv, "id");

  var idList = getAllCheckedIDs();

  var info = for (id <- idList) {

    if(id == myInfo.clientID) {

      [changeToRoom(myInfo, toRoom, serverPid)]
    } else {
      serverPid ! Send(id, RequestRoomChange(senderID = myInfo.clientID, senderName = myInfo.clientName, room = toRoom));
      []
    }
  };

  if (length(info) > 0) {
    hd(info)
  } else {
    myInfo
  }


}

fun dispRoomRequest(msg){
  var msgText = msg.senderName ^^ " wants you to move to room " ^^ msg.room;
  var msgXML =
    <tr><td>
      {stringToXml(msgText)}
    </td></tr>;


  appendChildren(msgXML, getNodeById("msgTable"))
}

fun handleMute(clientID){
  var vidToToggleMute = getNodeById("VidOf" ^^ clientID);
  if (not(isNull(vidToToggleMute))){

    if(domHasAttribute(vidToToggleMute, "muted")){

      domRemoveAttributeFromRef(vidToToggleMute, "muted")

    } else {

      domSetAttributeFromRef(vidToToggleMute, "muted", "true")

    }
  } else {}
}

## Loop thread run on the client, listens for NewClient messages from the server
## and prints a message to the console whenever one is received
fun clientLoop(serverPid, othersInfo, myInfo) {
    receive {
        case NewClient(msg) ->
          print("New client registered " ^^ msg.clientID);
          var othersNewInfo = msg :: othersInfo;
          clientLoop(serverPid, othersNewInfo, myInfo)


        case VidMessage(msg) ->
          print("VidMessage Received from " ^^ JSFFI.toString(msg.senderID));
          handleVidMessage(serverPid, msg);
          clientLoop(serverPid, othersInfo, myInfo)

        case StateUpdate(msg) ->
          print("StateUpdate Received");
          var othersNewInfo = handleStateUpdate(serverPid, othersInfo, myInfo, msg);
          clientLoop(serverPid, othersNewInfo, myInfo)

        case InitialState(msg) ->
          print("InitialState received");
          handleInitialState(msg);
          clientLoop(serverPid, msg, myInfo)

        case RequestRoomChange(msg) ->
          print("Request Received from " ^^ msg.senderID ^^ " for room " ^^ msg.room);
          dispRoomRequest(msg);
          clientLoop(serverPid, othersInfo, myInfo)

        case Migrate(event) ->
          print("Migrate Received");
          var myNewInfo = handleMigrate(serverPid, myInfo, event);
          clientLoop(serverPid, othersInfo, myNewInfo)

        case ToggleMute(msg) ->
          print("Muting " ^^ msg);
          JSFFI.togMute(msg);
          clientLoop(serverPid, othersInfo, myInfo)

    }
}

## Run on the client whenever the page has loaded.
## Registers itself with the server, then proceeds to loop, awaiting messages
## from the server
fun clientRegister(serverPid) {

    JSFFI.setName();
    JSFFI.setID();

    var name = JSFFI.getLocalName();
    var id = JSFFI.getID();
    displayLocalVid();

    var clientInfo = (clientID = id, clientName = name, room = "0");

    serverPid ! Register(self(), clientInfo);

    clientLoop(serverPid, [], clientInfo)
}

## Run on the server to generate a page for the client. Spawns a process on the
## client and generates the HTML.

fun mainPage(serverPid) {

  var clientPid = spawnClient { clientRegister(serverPid) };

  page
  <html>
    <div id = "rooms">
      <div id = "0">
        <form l:onsubmit="{clientPid ! Migrate(event)}">
          <button type="submit">Quiet Room</button>
        </form>
      </div>
      <div id = "1">
        <form l:onsubmit="{clientPid ! Migrate(event)}">
          <button type="submit">Room 1</button>
        </form>
      </div>
      <div id = "2">
        <form l:onsubmit="{clientPid ! Migrate(event)}">
          <button type="submit">Room 2</button>
        </form>
      </div>
    </div>
    <div id = "msgs">
      <table id = "msgTable">
      </table>
    </div>
    <div id = "vids"></div>

  </html>

}

### SERVER
## Sends a message to a list of clients
fun broadcast(clients, msg) server {
    switch (clients) {
        case [] -> ()
        case (c,_)::clients ->
            c ! msg;
            broadcast(clients, msg)
    }
}

# Loops, keeping track of the client PIDs
fun serverLoop(clients) server {
    receive {
        case Register(pid, clientInfo) ->
            var newClients = (pid, clientInfo) :: clients;

            # Broadcast a "NewClient" message
            broadcast(clients, NewClient(clientInfo));

            var infoToSend = for ((_ , clientInfo) <- newClients){
              [clientInfo]
            };

            broadcast([(pid, clientInfo)], InitialState(infoToSend));

            broadcast(clients, StateUpdate(clientInfo));

            serverLoop(newClients)

        case Send(targetID, msg) ->

          var target = for ((pid , clientInfo) <- clients)
            if (clientInfo.clientID == targetID) {
              [(pid , clientInfo)]
            } else {
              []
            };

            broadcast(target, msg);
            serverLoop(clients)

        case Broadcast(msg) ->
          broadcast(clients, msg);
          serverLoop(clients)

        case ChangeRoom(userID, newRoom) ->

          var newClients = for ((pid , clientInfo) <- clients)
            if (clientInfo.clientID == userID) {
              var id = clientInfo.clientID;
              var name = clientInfo.clientName;
              var newClientInfo = (clientID = id, clientName = name, room = newRoom);

              [(pid, newClientInfo)]
            }

            else
              [(pid, clientInfo)];

          var clientsToUpdate = for ((pid , clientInfo) <- newClients)
            if (clientInfo.clientID <> userID) {
              [(pid , clientInfo)]
            }
            else
              [];

          var clientInfoToSend = for ((pid , clientInfo) <- newClients)
            if (clientInfo.clientID == userID) {
              [clientInfo]
            }
            else
              [];

          var infoToSend = hd(clientInfoToSend);

          broadcast(clientsToUpdate, StateUpdate(infoToSend));

          serverLoop(newClients)

    }
}


# Main method, run once when the server is started
fun main() {
    # Spawns a process on the server which keeps track of all clients
    var serverPid = spawn { serverLoop([]) };
    # Registers the "mainPage" route
    addRoute("/", fun(_) { mainPage(serverPid) });
    addStaticRoute("/js", "js", [("js", "text/javascript")]);
    # Starts the server and distribution
    serveWebsockets();
    servePages()
}


main()
